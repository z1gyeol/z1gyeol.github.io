---
title: Polygon_Revolution
published: 2024-07-10
description: 'Diamond 3'
image: './spin.gif'
tags: [geometry,convex_hull,half_plane_intersection]
category: 'PS'
draft: false 
---
# Intro

[BOJ 22785](https://www.acmicpc.net/problem/22785)

  

예전에 아무도 못 푼 문제 리스트에서 우연히 발견하였다.
블로그를 어제 개설해서 이제야 풀이를 쓴다.

# 문제

  

Given a convex polygon with N vertices p1, . . . , pN  and a line L on a 2-dimensional plane. You can generate a 3-dimensional solid of revolution by the revolution of the convex polygon around the axis L. Now your mission is to calculate the volume of this solid.

When the axis L is an external line of the convex polygon, it’s much easier, because the following theorem will help you. However, you have to note that the axis may intersect the convex polygon.

**The second theorem of Pappus:**  The volume V of a solid of revolution generated by the revolution of a lamina about an external axis is equal to the product of the area A of the lamina and the distance traveled by the lamina’s geometric centroid  x.
  

The first line of the input is a positive integer T, denoting the number of test cases followed. The first line of each test case is a positive integer N (2 < N ≤ 100), which represents the number of vertices of the convex polygon. Then N lines follow. The i-th (1 ≤ i ≤ N) line contains two real numbers Xi (0 ≤ Xi ≤ 10000), Yi (0 ≤ Yi ≤ 10000) which give the coordinates of the vertices of the convex polygon in clockwise order. Finally, there are three real numbers A, B, C (−1000 ≤ A, B,C ≤ 1000) representing the equation of the axis Ax + By + C = 0.

<br><br><br>

그니까 볼록 다각형과 회전축이 주어졌을 때, 다각형을 회전축을 중심으로 회전하여 나온 입체 도형의 부피를 구하라는 것이다. 큰 발상은 필요 없다👍

  

그럼 해결해보도록 하자!

# Solution

1. 다각형이 나뉘는지 확인
+ 우선 축이 다각형을 뚫는지 확인을 해보자. 그냥 선분 교차 판정이다. 만약 다각형이 축에 의해 나눠지지 않는다면 그대로 회전하면 끝나는 단순한 문제가 되고 아니면 아쉽게도 귀찮은 짓거리를 해야 한다.
2. 접기
+ 다각형이 두 개로 나뉜다면 나눠져 나온 두 도형의 부피를 각각 구해서 더하고 회전했을 때 두 입체 도형의 공통되는 부피를 빼주면 된다. 공통된 입체 도형은 다각형의 공통된 부분을 회전한 것과 같다.
+ 나뉜 두 다각형을 각각 $A, B$라고 하자. 두 다각형의 공통 영역을 구하려면 둘 중 하나를 축에 대해 대칭 이동 해야 한다. 그럼 두 공통 영역이 반드시 생겨난다. 문제에서는 축을 $Ax+By+C=0$이라고 줬으니 편하게 계산하자. https://blog.naver.com/gt7461/220275701816 여기에 공식이 있다.
+ 대칭 이동에 성공했으면 공통된 영역을 구하자. https://www.acmicpc.net/problem/1077 이 문제와 같다. 여기서 반평면 교집합을 쓰면 아주아주아주아주 쉽고 간단하게 끝난다. 반평면 교집합 없이도 할 수 있으나 시간도 더 오래 걸리고 구현이 매우 귀찮다. $A$를 대칭이동 해서 $A'$이 나왔다고 하자. 그럼 그냥 $A',B$를 이루는 반평면들끼리 반평면 교집합을 돌린다. 그럼 공통 영역이 나온다.
3. 계산
+ 다 끝났고 부피 계산만이 남았다. 문제에 부피 구하는 방법은 나와있다. 그러므로 필요한 것은 다각형의 면적과 중심이다. 넓이는 그 유명한 신발끈 공식을 쓰면 되니 중심을 구해보자.
<br>
$C_x={1\over6A}\sum\limits^{n-1}_{k=0}(x_i+x_{i+1})(x_iy_{i+1}-x_{i+1}y_i)$
<br>
$C_x={1\over6A}\sum\limits^{n-1}_{k=0}(y_i+y_{i+1})(x_iy_{i+1}-x_{i+1}y_i)$
<br>
여기서 $A$는 넓이이다. 그리고 $i+1$에서 꼭 $(i+1)\%n$을 쓰자.
부피는 다음과 같다.
<br>
$V=2\pi A\overline x$
<br>
여기서 $\overline x$는 중심 $C$와 축 사이의 거리이다. 

이 문제는 당신에게 엄청난 정밀도를 요구할지도 모른다.
필자의 10번의 오답 코드 중 4번은 정밀도 때문이었다. 코드를 어떻게 짜느냐에 따라 다르겠지만 필자는 실수 오차가 큰 코드를 썼는지 엄청난 오차와 맞다이를 깠다.
이것까지 해결했다면 당신은 이 문제를 진짜 해결했다 ^.~
# Code

코드가 매우 상당히 더럽다; 이게 다 실수 오차 때문이다

```python
import sys
from math import atan2
from collections import deque
from decimal import *
D = Decimal
getcontext().prec = 50
inf = D('1e9')
eps = D('1e-9')
pi = D('3.141592653589793238462643383279502884197169399375105820974944592307816406286208998')
input = sys.stdin.readline
class pt2:
    def __init__(s, x, y):
        s.x = x
        s.y = y
    def __add__(s,o):
        return pt2(D(s.x)+D(o.x),D(s.y)+D(o.y))
    def __sub__(s,o):
        return pt2(D(s.x)-D(o.x),D(s.y)-D(o.y))
    def __mul__(s,k):
        return pt2(k*s.x,k*s.y)
    def equals(s, o):
        return s.x == o.x and s.y == o.y
    def norm2(s):
        return s.x**2+s.y**2
    def norm(s):
        return s.norm2()**.5
    def ccw(s,o,a):
        return (D(o.x)-D(s.x))*(D(a.y)-D(s.y))-(D(o.y)-D(s.y))*(D(a.x)-D(s.x))
    def cross(s,o):
        return s.x*o.y-s.y*o.x
    def dot(s,o):
        return s.x*o.x+s.y*o.y
class Halfplane:
    def __init__(s,p,pq):
        s.p = p
        pq -= p
        s.pq = pq
        s.angle = atan2(pq.y,pq.x)
    def out(s,r):
        return s.pq.cross(r-s.p) < -eps
    def __lt__(s,o):
        return s.angle < o.angle
    def inter(s, o):
        alpha = (o.p - s.p).cross(o.pq) / s.pq.cross(o.pq)
        return s.p + s.pq * alpha
def ccw(p1, p2, p3):
    return (p2[0]-p1[0])*(p3[1]-p1[1]) - (p2[1]-p1[1])*(p3[0]-p1[0])
def convex(A):
    A = sorted(A, key=lambda p: (p.x, p.y))
    up = []
    down = []
    for i in reversed(A):
        while len(up) >= 2 and up[-2].ccw(up[-1],i) <= 0:
            up.pop()
        up.append(i)
    for i in A:
        while len(down) >= 2 and down[-2].ccw(down[-1],i) <= 0:
            down.pop()
        down.append(i)
    return down[:-1] + up[:-1]
def PA(poly):
    poly.append(poly[0])
    s = D('0')
    for i in range(len(poly)-1):
        s += D(poly[i].x)*D(poly[i+1].y) - D(poly[i+1].x)*D(poly[i].y)
    return s/2
def HPI(H):
    box = [
        pt2(inf, inf), 
        pt2(-inf, inf), 
        pt2(-inf, -inf), 
        pt2(inf, -inf)
    ]

    for i in range(4):
        H.append(Halfplane(box[i], box[(i+1) % 4]))

    H.sort()
    dq = deque()
    len_dq = 0
    
    for h in H:
        while len_dq > 1 and h.out(Halfplane.inter(dq[-1], dq[-2])):
            dq.pop()
            len_dq -= 1
        while len_dq > 1 and h.out(Halfplane.inter(dq[0], dq[1])):
            dq.popleft()
            len_dq -= 1

        if len_dq > 0 and abs(h.pq.cross(dq[-1].pq)) < eps:
            if h.pq.dot(dq[-1].pq) < 0.0:
                return []
            if h.out(dq[-1].p):
                dq.pop()
                len_dq -= 1
            else:
                continue

        dq.append(h)
        len_dq += 1

    while len_dq > 2 and dq[0].out(Halfplane.inter(dq[-1], dq[-2])):
        dq.pop()
        len_dq -= 1

    while len_dq > 2 and dq[-1].out(Halfplane.inter(dq[0], dq[1])):
        dq.popleft()
        len_dq -= 1

    if len_dq < 3:
        return []

    ret = []
    for i in range(len_dq - 1):
        ret.append(Halfplane.inter(dq[i], dq[i + 1]))
    ret.append(Halfplane.inter(dq[-1], dq[0]))
    return ret
def findPoint(a,b,c,a1,b1,c1):
    d = a*b1 - a1*b
    if d == 0:
        if a*c1 != a1*c or b*c1 != b1*c:
            return None
        else:
            return pt2(65537.123,65537.123)
    x = D(b * c1 - b1 * c) / D(d)
    y = D(a1 * c - a * c1) / D(d)
    if x == -0.0:
        x = 0.0
    if y == -0.0:
        y = 0.0
    return pt2(x,y)
def corssPoint(a,b,c,p1,p2):
    a1 = p2.y - p1.y
    b1 = p1.x - p2.x
    c1 = p2.x*p1.y - p1.x*p2.y
    cp = findPoint(a,b,c,a1,b1,c1)
    if cp is None:return None
    if cp.equals(p1):return None
    if cp.equals(pt2(65537.123,65537.123)):return cp
    if min(p1.x,p2.x)-eps <= cp.x <= max(p1.x,p2.x)+eps and min(p1.y,p2.y)-eps <= cp.y <= max(p1.y,p2.y)+eps:return cp
    else:return None
def Centroid(P,A):
    x = y = 0
    P.append(P[0])
    for i in range(len(P)-1):
        x += D(D(P[i].x)+D(P[i+1].x))*D(D(P[i].x)*D(P[i+1].y)-D(P[i+1].x)*D(P[i].y))
        y += D(D(P[i].y)+D(P[i+1].y))*D(D(P[i].x)*D(P[i+1].y)-D(P[i+1].x)*D(P[i].y))
    x *= D('1')/D(6*A)
    y *= D('1')/D(6*A)
    return pt2(x,y)
def dist(a,b,c,p):
    return D(abs(a*p.x+b*p.y+c))/D((a**2+b**2)**D('0.5'))
def Flip(a,b,c,p):
    t = D('2')*D(D(a)*D(p.x)+D(b)*D(p.y)+D(c))/D(D(a)**D('2')+D(b)**D('2'))
    return pt2(D(p.x)-t*a,D(p.y)-t*b)
def Volume(P):
    S = PA(P)
    if S == 0:return 0
    C = Centroid(P,S)
    return 2*pi*S*dist(a,b,c,C)

for _ in '-'*int(input()):
    n = int(input())
    P = []
    A = []
    B = []
    H = []
    for _ in range(n):
        P.append(pt2(*map(D,input().split())))
    P = convex(P)
    n = len(P)
    a,b,c = map(D,input().split())
    z = 0
    flip = True
    cnt = 0
    for i in range(n):
        cp = corssPoint(a,b,c,P[i],P[(i+1)%n])
        if cp is not None and not z:
            A.append(cp)
            B.append(cp)
            cnt += 1
            z = 1
        elif cp is not None and z:
            A.append(P[i])
            A.append(cp)
            B.append(cp)
            cnt += 1
            z = 0
            break
        elif cp is None and z:
            A.append(P[i])
    for i in P:
        if i not in A:
            B.append(i)
    A = convex(A)
    B = convex(B)
    lenA = len(A)
    lenB = len(B)
    if lenA < 3 or lenB < 3 or cnt < 2:
        flip = False
    if not flip:
        print(Volume(P))
    else:
        for i in range(lenA):
            A[i] = Flip(a,b,c,A[i])
        A = A[::-1]
        for i in range(lenA):
            H.append(Halfplane(A[i],A[(i+1)%lenA]))
        for i in range(lenB):
            H.append(Halfplane(B[i],B[(i+1)%lenB]))
        H = HPI(H)
        print(Volume(A)+Volume(B)-Volume(H))
```

<br><br><br>

Well Done

![image](./thumb.jpg)