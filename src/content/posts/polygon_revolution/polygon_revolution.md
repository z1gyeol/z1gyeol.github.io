---
title: Polygon_Revolution
published: 2024-07-10
description: 'Diamond 3'
image: './spin.gif'
tags: [geometry,convex_hull,half_plane_intersection]
category: 'PS'
draft: false 
---
# Intro

[BOJ 22785](https://www.acmicpc.net/problem/22785)

  

ì˜ˆì „ì— ì•„ë¬´ë„ ëª» í‘¼ ë¬¸ì œ ë¦¬ìŠ¤íŠ¸ì—ì„œ ìš°ì—°íˆ ë°œê²¬í•˜ì˜€ë‹¤.
ë¸”ë¡œê·¸ë¥¼ ì–´ì œ ê°œì„¤í•´ì„œ ì´ì œì•¼ í’€ì´ë¥¼ ì“´ë‹¤.

# ë¬¸ì œ

  

Given a convex polygon with N vertices p1, . . . , pN  and a line L on a 2-dimensional plane. You can generate a 3-dimensional solid of revolution by the revolution of the convex polygon around the axis L. Now your mission is to calculate the volume of this solid.

When the axis L is an external line of the convex polygon, itâ€™s much easier, because the following theorem will help you. However, you have to note that the axis may intersect the convex polygon.

**The second theorem of Pappus:**  The volume V of a solid of revolution generated by the revolution of a lamina about an external axis is equal to the product of the area A of the lamina and the distance traveled by the laminaâ€™s geometric centroid  x.
  

The first line of the input is a positive integer T, denoting the number of test cases followed. The first line of each test case is a positive integer N (2 < N â‰¤ 100), which represents the number of vertices of the convex polygon. Then N lines follow. The i-th (1 â‰¤ i â‰¤ N) line contains two real numbers Xi (0 â‰¤ Xi â‰¤ 10000), Yi (0 â‰¤ Yi â‰¤ 10000) which give the coordinates of the vertices of the convex polygon in clockwise order. Finally, there are three real numbers A, B, C (âˆ’1000 â‰¤ A, B,C â‰¤ 1000) representing the equation of the axis Ax + By + C = 0.

<br><br><br>

ê·¸ë‹ˆê¹Œ ë³¼ë¡ ë‹¤ê°í˜•ê³¼ íšŒì „ì¶•ì´ ì£¼ì–´ì¡Œì„ ë•Œ, ë‹¤ê°í˜•ì„ íšŒì „ì¶•ì„ ì¤‘ì‹¬ìœ¼ë¡œ íšŒì „í•˜ì—¬ ë‚˜ì˜¨ ì…ì²´ ë„í˜•ì˜ ë¶€í”¼ë¥¼ êµ¬í•˜ë¼ëŠ” ê²ƒì´ë‹¤. í° ë°œìƒì€ í•„ìš” ì—†ë‹¤ğŸ‘

  

ê·¸ëŸ¼ í•´ê²°í•´ë³´ë„ë¡ í•˜ì!

# Solution

1. ë‹¤ê°í˜•ì´ ë‚˜ë‰˜ëŠ”ì§€ í™•ì¸
+ ìš°ì„  ì¶•ì´ ë‹¤ê°í˜•ì„ ëš«ëŠ”ì§€ í™•ì¸ì„ í•´ë³´ì. ê·¸ëƒ¥ ì„ ë¶„ êµì°¨ íŒì •ì´ë‹¤. ë§Œì•½ ë‹¤ê°í˜•ì´ ì¶•ì— ì˜í•´ ë‚˜ëˆ ì§€ì§€ ì•ŠëŠ”ë‹¤ë©´ ê·¸ëŒ€ë¡œ íšŒì „í•˜ë©´ ëë‚˜ëŠ” ë‹¨ìˆœí•œ ë¬¸ì œê°€ ë˜ê³  ì•„ë‹ˆë©´ ì•„ì‰½ê²Œë„ ê·€ì°®ì€ ì§“ê±°ë¦¬ë¥¼ í•´ì•¼ í•œë‹¤.
2. ì ‘ê¸°
+ ë‹¤ê°í˜•ì´ ë‘ ê°œë¡œ ë‚˜ë‰œë‹¤ë©´ ë‚˜ëˆ ì ¸ ë‚˜ì˜¨ ë‘ ë„í˜•ì˜ ë¶€í”¼ë¥¼ ê°ê° êµ¬í•´ì„œ ë”í•˜ê³  íšŒì „í–ˆì„ ë•Œ ë‘ ì…ì²´ ë„í˜•ì˜ ê³µí†µë˜ëŠ” ë¶€í”¼ë¥¼ ë¹¼ì£¼ë©´ ëœë‹¤. ê³µí†µëœ ì…ì²´ ë„í˜•ì€ ë‹¤ê°í˜•ì˜ ê³µí†µëœ ë¶€ë¶„ì„ íšŒì „í•œ ê²ƒê³¼ ê°™ë‹¤.
+ ë‚˜ë‰œ ë‘ ë‹¤ê°í˜•ì„ ê°ê° $A, B$ë¼ê³  í•˜ì. ë‘ ë‹¤ê°í˜•ì˜ ê³µí†µ ì˜ì—­ì„ êµ¬í•˜ë ¤ë©´ ë‘˜ ì¤‘ í•˜ë‚˜ë¥¼ ì¶•ì— ëŒ€í•´ ëŒ€ì¹­ ì´ë™ í•´ì•¼ í•œë‹¤. ê·¸ëŸ¼ ë‘ ê³µí†µ ì˜ì—­ì´ ë°˜ë“œì‹œ ìƒê²¨ë‚œë‹¤. ë¬¸ì œì—ì„œëŠ” ì¶•ì„ $Ax+By+C=0$ì´ë¼ê³  ì¤¬ìœ¼ë‹ˆ í¸í•˜ê²Œ ê³„ì‚°í•˜ì. https://blog.naver.com/gt7461/220275701816 ì—¬ê¸°ì— ê³µì‹ì´ ìˆë‹¤.
+ ëŒ€ì¹­ ì´ë™ì— ì„±ê³µí–ˆìœ¼ë©´ ê³µí†µëœ ì˜ì—­ì„ êµ¬í•˜ì. https://www.acmicpc.net/problem/1077 ì´ ë¬¸ì œì™€ ê°™ë‹¤. ì—¬ê¸°ì„œ ë°˜í‰ë©´ êµì§‘í•©ì„ ì“°ë©´ ì•„ì£¼ì•„ì£¼ì•„ì£¼ì•„ì£¼ ì‰½ê³  ê°„ë‹¨í•˜ê²Œ ëë‚œë‹¤. ë°˜í‰ë©´ êµì§‘í•© ì—†ì´ë„ í•  ìˆ˜ ìˆìœ¼ë‚˜ ì‹œê°„ë„ ë” ì˜¤ë˜ ê±¸ë¦¬ê³  êµ¬í˜„ì´ ë§¤ìš° ê·€ì°®ë‹¤. $A$ë¥¼ ëŒ€ì¹­ì´ë™ í•´ì„œ $A'$ì´ ë‚˜ì™”ë‹¤ê³  í•˜ì. ê·¸ëŸ¼ ê·¸ëƒ¥ $A',B$ë¥¼ ì´ë£¨ëŠ” ë°˜í‰ë©´ë“¤ë¼ë¦¬ ë°˜í‰ë©´ êµì§‘í•©ì„ ëŒë¦°ë‹¤. ê·¸ëŸ¼ ê³µí†µ ì˜ì—­ì´ ë‚˜ì˜¨ë‹¤.
3. ê³„ì‚°
+ ë‹¤ ëë‚¬ê³  ë¶€í”¼ ê³„ì‚°ë§Œì´ ë‚¨ì•˜ë‹¤. ë¬¸ì œì— ë¶€í”¼ êµ¬í•˜ëŠ” ë°©ë²•ì€ ë‚˜ì™€ìˆë‹¤. ê·¸ëŸ¬ë¯€ë¡œ í•„ìš”í•œ ê²ƒì€ ë‹¤ê°í˜•ì˜ ë©´ì ê³¼ ì¤‘ì‹¬ì´ë‹¤. ë„“ì´ëŠ” ê·¸ ìœ ëª…í•œ ì‹ ë°œëˆ ê³µì‹ì„ ì“°ë©´ ë˜ë‹ˆ ì¤‘ì‹¬ì„ êµ¬í•´ë³´ì.
<br>
$C_x={1\over6A}\sum\limits^{n-1}_{k=0}(x_i+x_{i+1})(x_iy_{i+1}-x_{i+1}y_i)$
<br>
$C_x={1\over6A}\sum\limits^{n-1}_{k=0}(y_i+y_{i+1})(x_iy_{i+1}-x_{i+1}y_i)$
<br>
ì—¬ê¸°ì„œ $A$ëŠ” ë„“ì´ì´ë‹¤. ê·¸ë¦¬ê³  $i+1$ì—ì„œ ê¼­ $(i+1)\%n$ì„ ì“°ì.
ë¶€í”¼ëŠ” ë‹¤ìŒê³¼ ê°™ë‹¤.
<br>
$V=2\pi A\overline x$
<br>
ì—¬ê¸°ì„œ $\overline x$ëŠ” ì¤‘ì‹¬ $C$ì™€ ì¶• ì‚¬ì´ì˜ ê±°ë¦¬ì´ë‹¤. 

ì´ ë¬¸ì œëŠ” ë‹¹ì‹ ì—ê²Œ ì—„ì²­ë‚œ ì •ë°€ë„ë¥¼ ìš”êµ¬í• ì§€ë„ ëª¨ë¥¸ë‹¤.
í•„ìì˜ 10ë²ˆì˜ ì˜¤ë‹µ ì½”ë“œ ì¤‘ 4ë²ˆì€ ì •ë°€ë„ ë•Œë¬¸ì´ì—ˆë‹¤. ì½”ë“œë¥¼ ì–´ë–»ê²Œ ì§œëŠëƒì— ë”°ë¼ ë‹¤ë¥´ê² ì§€ë§Œ í•„ìëŠ” ì‹¤ìˆ˜ ì˜¤ì°¨ê°€ í° ì½”ë“œë¥¼ ì¼ëŠ”ì§€ ì—„ì²­ë‚œ ì˜¤ì°¨ì™€ ë§ë‹¤ì´ë¥¼ ê¹ ë‹¤.
ì´ê²ƒê¹Œì§€ í•´ê²°í–ˆë‹¤ë©´ ë‹¹ì‹ ì€ ì´ ë¬¸ì œë¥¼ ì§„ì§œ í•´ê²°í–ˆë‹¤ ^.~
# Code

ì½”ë“œê°€ ë§¤ìš° ìƒë‹¹íˆ ë”ëŸ½ë‹¤; ì´ê²Œ ë‹¤ ì‹¤ìˆ˜ ì˜¤ì°¨ ë•Œë¬¸ì´ë‹¤

```python
import sys
from math import atan2
from collections import deque
from decimal import *
D = Decimal
getcontext().prec = 50
inf = D('1e9')
eps = D('1e-9')
pi = D('3.141592653589793238462643383279502884197169399375105820974944592307816406286208998')
input = sys.stdin.readline
class pt2:
    def __init__(s, x, y):
        s.x = x
        s.y = y
    def __add__(s,o):
        return pt2(D(s.x)+D(o.x),D(s.y)+D(o.y))
    def __sub__(s,o):
        return pt2(D(s.x)-D(o.x),D(s.y)-D(o.y))
    def __mul__(s,k):
        return pt2(k*s.x,k*s.y)
    def equals(s, o):
        return s.x == o.x and s.y == o.y
    def norm2(s):
        return s.x**2+s.y**2
    def norm(s):
        return s.norm2()**.5
    def ccw(s,o,a):
        return (D(o.x)-D(s.x))*(D(a.y)-D(s.y))-(D(o.y)-D(s.y))*(D(a.x)-D(s.x))
    def cross(s,o):
        return s.x*o.y-s.y*o.x
    def dot(s,o):
        return s.x*o.x+s.y*o.y
class Halfplane:
    def __init__(s,p,pq):
        s.p = p
        pq -= p
        s.pq = pq
        s.angle = atan2(pq.y,pq.x)
    def out(s,r):
        return s.pq.cross(r-s.p) < -eps
    def __lt__(s,o):
        return s.angle < o.angle
    def inter(s, o):
        alpha = (o.p - s.p).cross(o.pq) / s.pq.cross(o.pq)
        return s.p + s.pq * alpha
def ccw(p1, p2, p3):
    return (p2[0]-p1[0])*(p3[1]-p1[1]) - (p2[1]-p1[1])*(p3[0]-p1[0])
def convex(A):
    A = sorted(A, key=lambda p: (p.x, p.y))
    up = []
    down = []
    for i in reversed(A):
        while len(up) >= 2 and up[-2].ccw(up[-1],i) <= 0:
            up.pop()
        up.append(i)
    for i in A:
        while len(down) >= 2 and down[-2].ccw(down[-1],i) <= 0:
            down.pop()
        down.append(i)
    return down[:-1] + up[:-1]
def PA(poly):
    poly.append(poly[0])
    s = D('0')
    for i in range(len(poly)-1):
        s += D(poly[i].x)*D(poly[i+1].y) - D(poly[i+1].x)*D(poly[i].y)
    return s/2
def HPI(H):
    box = [
        pt2(inf, inf), 
        pt2(-inf, inf), 
        pt2(-inf, -inf), 
        pt2(inf, -inf)
    ]

    for i in range(4):
        H.append(Halfplane(box[i], box[(i+1) % 4]))

    H.sort()
    dq = deque()
    len_dq = 0
    
    for h in H:
        while len_dq > 1 and h.out(Halfplane.inter(dq[-1], dq[-2])):
            dq.pop()
            len_dq -= 1
        while len_dq > 1 and h.out(Halfplane.inter(dq[0], dq[1])):
            dq.popleft()
            len_dq -= 1

        if len_dq > 0 and abs(h.pq.cross(dq[-1].pq)) < eps:
            if h.pq.dot(dq[-1].pq) < 0.0:
                return []
            if h.out(dq[-1].p):
                dq.pop()
                len_dq -= 1
            else:
                continue

        dq.append(h)
        len_dq += 1

    while len_dq > 2 and dq[0].out(Halfplane.inter(dq[-1], dq[-2])):
        dq.pop()
        len_dq -= 1

    while len_dq > 2 and dq[-1].out(Halfplane.inter(dq[0], dq[1])):
        dq.popleft()
        len_dq -= 1

    if len_dq < 3:
        return []

    ret = []
    for i in range(len_dq - 1):
        ret.append(Halfplane.inter(dq[i], dq[i + 1]))
    ret.append(Halfplane.inter(dq[-1], dq[0]))
    return ret
def findPoint(a,b,c,a1,b1,c1):
    d = a*b1 - a1*b
    if d == 0:
        if a*c1 != a1*c or b*c1 != b1*c:
            return None
        else:
            return pt2(65537.123,65537.123)
    x = D(b * c1 - b1 * c) / D(d)
    y = D(a1 * c - a * c1) / D(d)
    if x == -0.0:
        x = 0.0
    if y == -0.0:
        y = 0.0
    return pt2(x,y)
def corssPoint(a,b,c,p1,p2):
    a1 = p2.y - p1.y
    b1 = p1.x - p2.x
    c1 = p2.x*p1.y - p1.x*p2.y
    cp = findPoint(a,b,c,a1,b1,c1)
    if cp is None:return None
    if cp.equals(p1):return None
    if cp.equals(pt2(65537.123,65537.123)):return cp
    if min(p1.x,p2.x)-eps <= cp.x <= max(p1.x,p2.x)+eps and min(p1.y,p2.y)-eps <= cp.y <= max(p1.y,p2.y)+eps:return cp
    else:return None
def Centroid(P,A):
    x = y = 0
    P.append(P[0])
    for i in range(len(P)-1):
        x += D(D(P[i].x)+D(P[i+1].x))*D(D(P[i].x)*D(P[i+1].y)-D(P[i+1].x)*D(P[i].y))
        y += D(D(P[i].y)+D(P[i+1].y))*D(D(P[i].x)*D(P[i+1].y)-D(P[i+1].x)*D(P[i].y))
    x *= D('1')/D(6*A)
    y *= D('1')/D(6*A)
    return pt2(x,y)
def dist(a,b,c,p):
    return D(abs(a*p.x+b*p.y+c))/D((a**2+b**2)**D('0.5'))
def Flip(a,b,c,p):
    t = D('2')*D(D(a)*D(p.x)+D(b)*D(p.y)+D(c))/D(D(a)**D('2')+D(b)**D('2'))
    return pt2(D(p.x)-t*a,D(p.y)-t*b)
def Volume(P):
    S = PA(P)
    if S == 0:return 0
    C = Centroid(P,S)
    return 2*pi*S*dist(a,b,c,C)

for _ in '-'*int(input()):
    n = int(input())
    P = []
    A = []
    B = []
    H = []
    for _ in range(n):
        P.append(pt2(*map(D,input().split())))
    P = convex(P)
    n = len(P)
    a,b,c = map(D,input().split())
    z = 0
    flip = True
    cnt = 0
    for i in range(n):
        cp = corssPoint(a,b,c,P[i],P[(i+1)%n])
        if cp is not None and not z:
            A.append(cp)
            B.append(cp)
            cnt += 1
            z = 1
        elif cp is not None and z:
            A.append(P[i])
            A.append(cp)
            B.append(cp)
            cnt += 1
            z = 0
            break
        elif cp is None and z:
            A.append(P[i])
    for i in P:
        if i not in A:
            B.append(i)
    A = convex(A)
    B = convex(B)
    lenA = len(A)
    lenB = len(B)
    if lenA < 3 or lenB < 3 or cnt < 2:
        flip = False
    if not flip:
        print(Volume(P))
    else:
        for i in range(lenA):
            A[i] = Flip(a,b,c,A[i])
        A = A[::-1]
        for i in range(lenA):
            H.append(Halfplane(A[i],A[(i+1)%lenA]))
        for i in range(lenB):
            H.append(Halfplane(B[i],B[(i+1)%lenB]))
        H = HPI(H)
        print(Volume(A)+Volume(B)-Volume(H))
```

<br><br><br>

Well Done

![image](./thumb.jpg)